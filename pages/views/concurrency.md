## c. Представление многозадачности

**Цель**: Показать, как система обрабатывает множество одновременных запросов и поддерживает целостность данных.

**Для кого**: Разработчики, инженеры надежности (SRE).

**Модель параллелизма и обработки**:
1. Уровень входящих запросов (API Gateway):
* Stateless обработка. Каждый HTTP-запрос обрабатывается независимо.
* Rate Limiting на уровне API Gateway для защиты от DDoS.
* Балансировка нагрузки между несколькими экземплярами монолита.
2. Уровень бизнес-логики (Монолит):
* Многопоточная модель. Каждый экземпляр монолита обрабатывает множество запросов параллельно (thread-per-request в Java, goroutines в Go).
* Критические секции: Операции, меняющие состояние агрегата (например, финиш тренировки), защищены пессимистическими блокировками на уровне строк БД или оптимистической блокировкой (version).
3. Уровень обработки событий (Kafka Consumers):
* Параллельное потребление. Сервисы-потребители (Notification, Analytics) запускают несколько consumer-потоков для параллельной обработки событий из партиций Kafka.
* Гарантия порядка: Порядок событий гарантируется в пределах партиции. Например, все события одного пользователя (user_id) попадают в одну партицию, сохраняя порядок.
4. Уровень доступа к данным (БД):
* Пул соединений (Connection Pool) в монолите для эффективного взаимодействия с PostgreSQL.
* Read Replicas для аналитических запросов админ-панели, чтобы не нагружать master.

**Обработка пиков**:
* Вертикальное масштабирование: Увеличение CPU/RAM для инстансов монолита и БД.
* Горизонтальное масштабирование: Добавление инстансов монолита (stateless) и увеличение партиций/консьюмеров для Kafka.
* Буферизация в Kafka: Пиковые 10 000 завершений тренировок сначала попадают в топик workout.completed, откуда потребляются с регулируемой скоростью.