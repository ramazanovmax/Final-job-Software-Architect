## 10) Анализ и описание архитектурных опций и обоснование выбора. 

|Стиль архитектуры|Плюсы|Минусы|Итоговое решение|
|----|----|-----|-|
|**Монолит**|• Простота разработки и отладки на старте.<br> • Простота развертывания (один артефакт).<br>• Согласованность данных (ACID-транзакции).<br>• Низкие накладные расходы на коммуникацию.|• Сложность масштабирования: масштабируем только целиком, дублируя всё приложение.<br> • Риск для надежности: баг в одном модуле может повалить всю систему.<br> • Медленный цикл разработки при росте команды.<br>• Технологический lock-in: сложно применять разные стеки для разных задач.<br>• Сложное понимание кодовой базы при разрастании.|Отклонено на среднесрок|
|**Модульный монолит**|• Сохраняет простоту разработки и деплоя монолита на старте. <br>• Чёткие границы модулей облегчают будущее разделение на микросервисы. <br>• Позволяет масштабировать команды. |• Масштабируется как монолит <br>• Общее хранилище данных может создавать скрытые связи между модулями. <br>• Риск нарушения границ модулей при спешке.|Да, но с чёткими Bounded Contexts|
|**Слоистая Архитектура**|• Четкое разделение ответственности. <br>• Легко понять и стандартизировать. <br>• Хороша для старта команд. |• "Гниение" архитектуры: бизнес-логика "просачивается" в другие слои.<br>• Слабая масштабируемость, как у монолита.<br>• Слои становятся препятствиями для производительности и независимых развертываний. |Не рассматривать как основной стиль.|
|**Событийно-ориентированная Архитектура**|• Максимальная слабая связность и отказоустойчивость.<br>• Отличная буферизация пиковых нагрузок.<br>• Позволяет легко добавлять новых потребителей событий.<br> • Хорошо подходит для геймификации и аналитики в реальном времени.|• Сложность в понимании потоков данных (нет явного вызова).<br>• Сложность обеспечения порядка и идемпотентности.<br>• Отладка сложнее из-за асинхронности.<br>• Не подходит для всех типов взаимодействий (например, немедленный ответ на запрос).|Принять как ключевой комплементарный стиль к микросервисам.|
|**Микросервисы** |• Независимое масштабирование: можно масштабировать только перегруженный сервис (например, обработку тренировок).<br>• Повышенная надежность: изоляция сбоев.<br>• Технологическая гибкость: каждый сервис на своем стеке.<br> • Независимые циклы разработки и деплоя для разных команд.<br>• Улучшает наблюдаемость через четкие границы.|• Высокая сложность: распределенные транзакции, eventual consistency, отладка.<br>• Накладные расходы на межсервисную коммуникацию.<br>• Сложность развертывания и оркестрации<br>• Требует зрелой DevOps-культуры.|Целевая архитектура с 9-го месяца|
#

### Исходя из анализа, не существует одного идеального стиля для всей системы. Требуется гибридный подход, основанный на доменном контексте и нефункциональных требованиях.
### Лучшим вариантом в данном случае будет старт проекта с модульного монолита с последующей миграцией в Микросервисы.

